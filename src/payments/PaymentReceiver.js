const { v4: uuidv4 } = require('uuid')

const { PaymentObject, PAYMENT_DIRECTION, PAYMENT_STATE } = require('./PaymentObject')
const { SLASHPAY_PATH } = require('../slashtags')
/**
 * PaymentReceiver is a class which is responsible for making plugins to receive payments
 * @class PaymentReceiver
 */
class PaymentReceiver {
  /**
   * @constructor PaymentReceiver
   * @param {DB} db - instance of a database
   * @param {PluginManager} pluginManager - instance of a plugin manager
   * @param {RemoteStorage} storage - instance of a local storage (e.g. HyperDrive)
   * @param {Function} notificationCallback - callback which is called when payment is received
   */
  constructor (db, pluginManager, storage, notificationCallback) {
    this.db = db // internal state storage
    this.storage = storage // internal public interface
    this.notificationCallback = notificationCallback
    this.pluginManager = pluginManager
    this.ready = false
  }

  /**
   * Initialize, get ready to receive payments at returned URL
   * @param {PaymentAmount} [amount] - amount of money to receive
   * @returns {Promise<String>} - url to local drive where slashpay.json file is located
   */
  async init () {
    const paymentPluginNames = this.getListOfSupportedPaymentMethods()
    const { id, slashpayFile } = await this.generateSlashpayContent(paymentPluginNames)
    const url = await this.storage.create(SLASHPAY_PATH, slashpayFile, { awaitRelaySync: true })

    const payload = { id, notificationCallback: this.notificationCallback.bind(this) }

    await this.pluginManager.dispatchEvent('receivePayment', payload)
    this.ready = true

    return url
  }

  /**
   * Create private payment endpoints which are encrypted
   * @param {string} id - invoice id
   * @param {PaymentAmount} amount - amount of money to receive
   * @returns {Promise<String>} - url to local drive where slashpay.json file is located
  */
  async createInvoice (id, amount) {
    if (!this.ready) throw new Error(ERRORS.PAYMENT_RECEIVER_NOT_READY)

    const paymentPluginNames = this.getListOfSupportedPaymentMethods()
    const { slashpayFile } = await this.generateSlashpayContent(paymentPluginNames, id)

    const url = await this.storage.create(`slashpay/${id}/slashpay.json`, slashpayFile, { encrypt: true, awaitRelaySync: true })

    const payload = { id, notificationCallback: this.notificationCallback.bind(this) }
    payload.amount = amount.serialize()
    // TODO: return id by plugin so that it is correlated to the paymentFile

    await this.pluginManager.dispatchEvent('receivePayment', payload)

    return url
  }

  /**
   * Sotres payload (generated by plugin) data in to file
   * @param {Object} payload - payload to receive payment 
   */
  async createPaymentFile (payload, path = `/public/slashpay/${payload.pluginName}/slashpay.json`) {
    if (payload.isPersonalPayment) {
      // TODO: (encrypt if personal payment and store under private path)
      throw new Error('Personal payements are not yet supported')
      if (!payload.isPersonalPayment) throw new Error(PAYLOAD_ID_IS_MISSING)
    }

    await this.storage.create(path, payload.data, { awaitRelaySync: true })
  }

  /**
   * Callback which is called by plugin when payment is received
   * @param {Object} payload - payment object
   * @returns {Promise<void>}
   */
  async handleNewPayment (payload, regenerateSlashpay = true) {
    const paymentObject = new PaymentObject({
      orderId: uuidv4(),
      sendingPriority: [payload.pluginName],
      direction: PAYMENT_DIRECTION.IN,
      internalState: PAYMENT_STATE.COMPLETED,

      counterpartyURL: await this.storage.getUrl(), // we cant really know this so it may always be receiver

      completedByPlugin: {
        name: payload.pluginName,
        state: 'success', // XXX should I read it from plugin?
        startAt: Date.now(),
        endAt: Date.now()
      },

      // FROM PAYLOAD
      amount: payload.amount, // send it in payload
      memo: payload.memo || '', // send it in payload
      denomination: payload.denomination || 'BASE',
      currency: payload.currency || 'BTC',
      clientOrderId: payload.clientOrderId // send in payload
    }, this.db)
    await paymentObject.save()

    if (regenerateSlashpay) {
      await this.init()
    }

    await this.notificationCallback(paymentObject)
  }

  /**
   * @method generateSlashpayContent
   * @param {Array<String>} paymentPluginNames - list of payment plugin names
   * @param {string} [id] - id of invoice
   * @returns {Object} - content of slashpay.json file
   */
  async generateSlashpayContent (paymentPluginNames, id) {
    const slashpayFile = { paymentEndpoints: {} }
    for (let name of paymentPluginNames) {
      slashpayFile.paymentEndpoints[name] = await this.storage.getUrl(...this.getUrlParams(name, id))
    }

    return {
      id,
      slashpayFile
    }
  }

  getUrlParams(name, id) {
    let p
    const opts = {}
    if (!id) {
      id = uuidv4()
      p = `/public/slashpay/${name}/slashpay.json`
    } else {
      p = `/slashpay/${id}/${name}/slashpay.json`
      opts.encrypt = true
    }
    return [p, opts]
  }

  /**
   * @method updateSlashpayContent
   * @param {String} id - invoice id
   */
  async updateSlashpayContent(paymentPluginNames, id) {
    // TODO: read current content of slashpay.json
    const slashpayFile = { paymentEndpoints: {} }

    for (let name of paymentPluginNames) {
      slashpayFile.paymentEndpoints[name] = await this.storage.getUrl(...this.getUrlParams(name, id))
    }

    return {
      slashpayFile,
      id
    }
  }

  /**
   * @method getListOfSupportedPaymentMethods
   * @returns {Array<String>} - list of payment plugin names
   */
  getListOfSupportedPaymentMethods () {
    return Object.entries(this.pluginManager.getPlugins(true))
      .filter(([_name, { manifest }]) => manifest.type === 'payment')
      .map(([name, _plugin]) => name)
  }
}

const ERRORS = {
  PAYMENT_RECEIVER_NOT_READY: 'PAYMENT_RECEIVER_NOT_READY',
  PAYLOAD_ID_IS_MISSING: 'PAYLOAD_ID_IS_MISSING'
}

module.exports = {
  PaymentReceiver,
  ERRORS
}
